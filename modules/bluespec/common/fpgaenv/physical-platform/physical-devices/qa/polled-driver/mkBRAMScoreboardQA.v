//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Wed Sep 17 21:54:20 EDT 2014
//
// BVI format method schedule info:
// schedule enq  CF ( setValue, first, deq, notFull, notEmpty, deqEntryId );
// schedule enq  C ( enq );
//
// schedule setValue  CF ( enq, notFull );
// schedule setValue  SBR ( first, deq, notEmpty, deqEntryId );
// schedule setValue  C ( setValue );
//
// schedule first  CF ( enq, first, notFull, notEmpty, deqEntryId );
// schedule first  SB ( deq );
//
// schedule deq  CF ( enq, notFull );
// schedule deq  C ( deq );
//
// schedule notFull  CF ( enq,
// 		       setValue,
// 		       first,
// 		       deq,
// 		       notFull,
// 		       notEmpty,
// 		       deqEntryId );
//
// schedule notEmpty  CF ( enq, first, notFull, notEmpty, deqEntryId );
// schedule notEmpty  SB ( deq );
//
// schedule deqEntryId  CF ( enq, first, notFull, notEmpty, deqEntryId );
// schedule deqEntryId  SB ( deq );
//
//
// Ports:
// Name                         I/O  size props
// enq                            O     6 reg
// RDY_enq                        O     1
// RDY_setValue                   O     1
// first                          O   512
// RDY_first                      O     1
// RDY_deq                        O     1
// notFull                        O     1
// RDY_notFull                    O     1 const
// notEmpty                       O     1
// RDY_notEmpty                   O     1 const
// deqEntryId                     O     6
// RDY_deqEntryId                 O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// setValue_id                    I     6
// setValue_data                  I   512
// EN_setValue                    I     1
// EN_deq                         I     1
// EN_enq                         I     1
//
// Combinational paths from inputs to outputs:
//   (setValue_id, setValue_data, EN_setValue) -> first
//   (setValue_id, setValue_data, EN_setValue) -> RDY_first
//   (setValue_id, setValue_data, EN_setValue) -> RDY_deq
//   (setValue_id, setValue_data, EN_setValue) -> notEmpty
//   (setValue_id, setValue_data, EN_setValue) -> deqEntryId
//   (setValue_id, setValue_data, EN_setValue) -> RDY_deqEntryId
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBRAMScoreboardQPI(CLK,
			   RST_N,

			   EN_enq,
			   enq,
			   RDY_enq,

			   setValue_id,
			   setValue_data,
			   EN_setValue,
			   RDY_setValue,

			   first,
			   RDY_first,

			   EN_deq,
			   RDY_deq,

			   notFull,
			   RDY_notFull,

			   notEmpty,
			   RDY_notEmpty,

			   deqEntryId,
			   RDY_deqEntryId);
  input  CLK;
  input  RST_N;

  // actionvalue method enq
  input  EN_enq;
  output [5 : 0] enq;
  output RDY_enq;

  // action method setValue
  input  [5 : 0] setValue_id;
  input  [511 : 0] setValue_data;
  input  EN_setValue;
  output RDY_setValue;

  // value method first
  output [511 : 0] first;
  output RDY_first;

  // action method deq
  input  EN_deq;
  output RDY_deq;

  // value method notFull
  output notFull;
  output RDY_notFull;

  // value method notEmpty
  output notEmpty;
  output RDY_notEmpty;

  // value method deqEntryId
  output [5 : 0] deqEntryId;
  output RDY_deqEntryId;

  // signals for module outputs
  wire [511 : 0] first;
  wire [5 : 0] deqEntryId, enq;
  wire RDY_deq,
       RDY_deqEntryId,
       RDY_enq,
       RDY_first,
       RDY_notEmpty,
       RDY_notFull,
       RDY_setValue,
       notEmpty,
       notFull;

  // inlined wires
  wire [518 : 0] m_exitValQ_rv_port0__write_1,
		 m_exitValQ_rv_port1__read,
		 m_exitValQ_rv_port2__read,
		 m_setValueQ_rv_port0__write_1,
		 m_setValueQ_rv_port1__read,
		 m_setValueQ_rv_port2__read;
  wire m_exitValQ_rv_EN_port0__write,
       m_nEntries_downByW_whas,
       m_oldestIsReady_wget;

  // register m_didInit
  reg m_didInit;
  wire m_didInit_D_IN, m_didInit_EN;

  // register m_exitValQ_rv
  reg [518 : 0] m_exitValQ_rv;
  wire [518 : 0] m_exitValQ_rv_D_IN;
  wire m_exitValQ_rv_EN;

  // register m_initIdx
  reg [5 : 0] m_initIdx;
  wire [5 : 0] m_initIdx_D_IN;
  wire m_initIdx_EN;

  // register m_nEntries_ctr
  reg [6 : 0] m_nEntries_ctr;
  wire [6 : 0] m_nEntries_ctr_D_IN;
  wire m_nEntries_ctr_EN;

  // register m_nEntries_zero
  reg m_nEntries_zero;
  wire m_nEntries_zero_D_IN, m_nEntries_zero_EN;

  // register m_nextDeq
  reg [5 : 0] m_nextDeq;
  wire [5 : 0] m_nextDeq_D_IN;
  wire m_nextDeq_EN;

  // register m_nextEnq
  reg [5 : 0] m_nextEnq;
  wire [5 : 0] m_nextEnq_D_IN;
  wire m_nextEnq_EN;

  // register m_setValueQ_rv
  reg [518 : 0] m_setValueQ_rv;
  wire [518 : 0] m_setValueQ_rv_D_IN;
  wire m_setValueQ_rv_EN;

  // register m_values_bufferingAvailable_ctr
  reg [1 : 0] m_values_bufferingAvailable_ctr;
  wire [1 : 0] m_values_bufferingAvailable_ctr_D_IN;
  wire m_values_bufferingAvailable_ctr_EN;

  // register m_values_bufferingAvailable_zero
  reg m_values_bufferingAvailable_zero;
  wire m_values_bufferingAvailable_zero_D_IN,
       m_values_bufferingAvailable_zero_EN;

  // register m_values_ram_mem_outputR
  reg [511 : 0] m_values_ram_mem_outputR;
  wire [511 : 0] m_values_ram_mem_outputR_D_IN;
  wire m_values_ram_mem_outputR_EN;

  // register m_values_readReqMade_ctr
  reg m_values_readReqMade_ctr;
  wire m_values_readReqMade_ctr_D_IN, m_values_readReqMade_ctr_EN;

  // register m_values_readReqMade_zero
  reg m_values_readReqMade_zero;
  wire m_values_readReqMade_zero_D_IN, m_values_readReqMade_zero_EN;

  // ports of submodule m_exitEntryIdQ
  wire [5 : 0] m_exitEntryIdQ_D_IN, m_exitEntryIdQ_D_OUT;
  wire m_exitEntryIdQ_CLR,
       m_exitEntryIdQ_DEQ,
       m_exitEntryIdQ_EMPTY_N,
       m_exitEntryIdQ_ENQ,
       m_exitEntryIdQ_FULL_N;

  // ports of submodule m_readyVec_mem_mem
  wire [5 : 0] m_readyVec_mem_mem_ADDR_1,
	       m_readyVec_mem_mem_ADDR_2,
	       m_readyVec_mem_mem_ADDR_3,
	       m_readyVec_mem_mem_ADDR_4,
	       m_readyVec_mem_mem_ADDR_5,
	       m_readyVec_mem_mem_ADDR_IN;
  wire m_readyVec_mem_mem_D_IN,
       m_readyVec_mem_mem_D_OUT_1,
       m_readyVec_mem_mem_WE;

  // ports of submodule m_reqVec_mem_mem
  wire [5 : 0] m_reqVec_mem_mem_ADDR_1,
	       m_reqVec_mem_mem_ADDR_2,
	       m_reqVec_mem_mem_ADDR_3,
	       m_reqVec_mem_mem_ADDR_4,
	       m_reqVec_mem_mem_ADDR_5,
	       m_reqVec_mem_mem_ADDR_IN;
  wire m_reqVec_mem_mem_D_IN,
       m_reqVec_mem_mem_D_OUT_1,
       m_reqVec_mem_mem_D_OUT_2,
       m_reqVec_mem_mem_D_OUT_3,
       m_reqVec_mem_mem_WE;

  // ports of submodule m_values_buffer_ff
  wire [511 : 0] m_values_buffer_ff_D_IN, m_values_buffer_ff_D_OUT;
  wire m_values_buffer_ff_CLR,
       m_values_buffer_ff_DEQ,
       m_values_buffer_ff_EMPTY_N,
       m_values_buffer_ff_ENQ,
       m_values_buffer_ff_FULL_N;

  // ports of submodule m_values_buffer_firstValid
  wire m_values_buffer_firstValid_D_IN,
       m_values_buffer_firstValid_EN,
       m_values_buffer_firstValid_Q_OUT;

  // ports of submodule m_values_ram_mem_ram
  wire [511 : 0] m_values_ram_mem_ram_D_IN, m_values_ram_mem_ram_D_OUT_1;
  wire [5 : 0] m_values_ram_mem_ram_ADDR_1,
	       m_values_ram_mem_ram_ADDR_2,
	       m_values_ram_mem_ram_ADDR_3,
	       m_values_ram_mem_ram_ADDR_4,
	       m_values_ram_mem_ram_ADDR_5,
	       m_values_ram_mem_ram_ADDR_IN;
  wire m_values_ram_mem_ram_WE;

  // rule scheduling signals
  wire CAN_FIRE_RL_m_bypassOldest,
       CAN_FIRE_RL_m_checkOldest,
       CAN_FIRE_RL_m_doAllocSlot,
       CAN_FIRE_RL_m_doInit,
       CAN_FIRE_RL_m_nEntries_updateCounter,
       CAN_FIRE_RL_m_readReqOldest,
       CAN_FIRE_RL_m_readRespOldest,
       CAN_FIRE_RL_m_receiveValues,
       CAN_FIRE_RL_m_values_buffer_dequeue,
       CAN_FIRE_RL_m_values_buffer_enqueue,
       CAN_FIRE_RL_m_values_bufferingAvailable_updateCounter,
       CAN_FIRE_RL_m_values_enqIntoFIFO,
       CAN_FIRE_RL_m_values_readReqMade_updateCounter,
       CAN_FIRE_deq,
       CAN_FIRE_enq,
       CAN_FIRE_setValue,
       WILL_FIRE_RL_m_bypassOldest,
       WILL_FIRE_RL_m_checkOldest,
       WILL_FIRE_RL_m_doAllocSlot,
       WILL_FIRE_RL_m_doInit,
       WILL_FIRE_RL_m_nEntries_updateCounter,
       WILL_FIRE_RL_m_readReqOldest,
       WILL_FIRE_RL_m_readRespOldest,
       WILL_FIRE_RL_m_receiveValues,
       WILL_FIRE_RL_m_values_buffer_dequeue,
       WILL_FIRE_RL_m_values_buffer_enqueue,
       WILL_FIRE_RL_m_values_bufferingAvailable_updateCounter,
       WILL_FIRE_RL_m_values_enqIntoFIFO,
       WILL_FIRE_RL_m_values_readReqMade_updateCounter,
       WILL_FIRE_deq,
       WILL_FIRE_enq,
       WILL_FIRE_setValue;

  // inputs to muxes for submodule ports
  wire [518 : 0] MUX_m_exitValQ_rv_port0__write_1__VAL_1,
		 MUX_m_exitValQ_rv_port0__write_1__VAL_2;
  wire MUX_m_readyVec_mem_mem_upd_1__SEL_1;

  // remaining internal signals
  wire [517 : 0] m_setValueQ_rvport1__read_BITS_517_TO_0__q1;
  wire [511 : 0] x__h4237;
  wire [6 : 0] new_value__h408, x__h425, y__h394, y__h396;
  wire [1 : 0] new_value__h1869, x__h1886, y__h1855, y__h1857;
  wire new_value__h1444, x__h1461;

  // actionvalue method enq
  assign enq = m_nextEnq ;
  assign RDY_enq = m_nEntries_ctr != 7'd64 ;
  assign CAN_FIRE_enq = m_nEntries_ctr != 7'd64 ;
  assign WILL_FIRE_enq = EN_enq ;

  // action method setValue
  assign RDY_setValue = !m_setValueQ_rv[518] ;
  assign CAN_FIRE_setValue = !m_setValueQ_rv[518] ;
  assign WILL_FIRE_setValue = EN_setValue ;

  // value method first
  assign first = m_exitValQ_rv_port1__read[517:6] ;
  assign RDY_first = m_exitValQ_rv_port1__read[518] ;

  // action method deq
  assign RDY_deq = m_exitValQ_rv_port1__read[518] ;
  assign CAN_FIRE_deq = m_exitValQ_rv_port1__read[518] ;
  assign WILL_FIRE_deq = EN_deq ;

  // value method notFull
  assign notFull = m_nEntries_ctr != 7'd64 ;
  assign RDY_notFull = 1'd1 ;

  // value method notEmpty
  assign notEmpty = m_exitValQ_rv_port1__read[518] ;
  assign RDY_notEmpty = 1'd1 ;

  // value method deqEntryId
  assign deqEntryId = m_exitValQ_rv_port1__read[5:0] ;
  assign RDY_deqEntryId = m_exitValQ_rv_port1__read[518] ;

  // submodule m_exitEntryIdQ
  FIFO2 #(.width(32'd6), .guarded(32'd1)) m_exitEntryIdQ(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(m_exitEntryIdQ_D_IN),
							 .ENQ(m_exitEntryIdQ_ENQ),
							 .DEQ(m_exitEntryIdQ_DEQ),
							 .CLR(m_exitEntryIdQ_CLR),
							 .D_OUT(m_exitEntryIdQ_D_OUT),
							 .FULL_N(m_exitEntryIdQ_FULL_N),
							 .EMPTY_N(m_exitEntryIdQ_EMPTY_N));

  // submodule m_readyVec_mem_mem
  RegFile #(.addr_width(32'd6),
	    .data_width(32'd1),
	    .lo(6'h0),
	    .hi(6'd63)) m_readyVec_mem_mem(.CLK(CLK),
					   .ADDR_1(m_readyVec_mem_mem_ADDR_1),
					   .ADDR_2(m_readyVec_mem_mem_ADDR_2),
					   .ADDR_3(m_readyVec_mem_mem_ADDR_3),
					   .ADDR_4(m_readyVec_mem_mem_ADDR_4),
					   .ADDR_5(m_readyVec_mem_mem_ADDR_5),
					   .ADDR_IN(m_readyVec_mem_mem_ADDR_IN),
					   .D_IN(m_readyVec_mem_mem_D_IN),
					   .WE(m_readyVec_mem_mem_WE),
					   .D_OUT_1(m_readyVec_mem_mem_D_OUT_1),
					   .D_OUT_2(),
					   .D_OUT_3(),
					   .D_OUT_4(),
					   .D_OUT_5());

  // submodule m_reqVec_mem_mem
  RegFile #(.addr_width(32'd6),
	    .data_width(32'd1),
	    .lo(6'h0),
	    .hi(6'd63)) m_reqVec_mem_mem(.CLK(CLK),
					 .ADDR_1(m_reqVec_mem_mem_ADDR_1),
					 .ADDR_2(m_reqVec_mem_mem_ADDR_2),
					 .ADDR_3(m_reqVec_mem_mem_ADDR_3),
					 .ADDR_4(m_reqVec_mem_mem_ADDR_4),
					 .ADDR_5(m_reqVec_mem_mem_ADDR_5),
					 .ADDR_IN(m_reqVec_mem_mem_ADDR_IN),
					 .D_IN(m_reqVec_mem_mem_D_IN),
					 .WE(m_reqVec_mem_mem_WE),
					 .D_OUT_1(m_reqVec_mem_mem_D_OUT_1),
					 .D_OUT_2(m_reqVec_mem_mem_D_OUT_2),
					 .D_OUT_3(m_reqVec_mem_mem_D_OUT_3),
					 .D_OUT_4(),
					 .D_OUT_5());

  // submodule m_values_buffer_ff
  FIFO2 #(.width(32'd512), .guarded(32'd0)) m_values_buffer_ff(.RST(RST_N),
							       .CLK(CLK),
							       .D_IN(m_values_buffer_ff_D_IN),
							       .ENQ(m_values_buffer_ff_ENQ),
							       .DEQ(m_values_buffer_ff_DEQ),
							       .CLR(m_values_buffer_ff_CLR),
							       .D_OUT(m_values_buffer_ff_D_OUT),
							       .FULL_N(m_values_buffer_ff_FULL_N),
							       .EMPTY_N(m_values_buffer_ff_EMPTY_N));

  // submodule m_values_buffer_firstValid
  RevertReg #(.width(32'd1),
	      .init(1'd1)) m_values_buffer_firstValid(.CLK(CLK),
						      .D_IN(m_values_buffer_firstValid_D_IN),
						      .EN(m_values_buffer_firstValid_EN),
						      .Q_OUT(m_values_buffer_firstValid_Q_OUT));

  // submodule m_values_ram_mem_ram
  RegFile #(.addr_width(32'd6),
	    .data_width(32'd512),
	    .lo(6'h0),
	    .hi(6'd63)) m_values_ram_mem_ram(.CLK(CLK),
					     .ADDR_1(m_values_ram_mem_ram_ADDR_1),
					     .ADDR_2(m_values_ram_mem_ram_ADDR_2),
					     .ADDR_3(m_values_ram_mem_ram_ADDR_3),
					     .ADDR_4(m_values_ram_mem_ram_ADDR_4),
					     .ADDR_5(m_values_ram_mem_ram_ADDR_5),
					     .ADDR_IN(m_values_ram_mem_ram_ADDR_IN),
					     .D_IN(m_values_ram_mem_ram_D_IN),
					     .WE(m_values_ram_mem_ram_WE),
					     .D_OUT_1(m_values_ram_mem_ram_D_OUT_1),
					     .D_OUT_2(),
					     .D_OUT_3(),
					     .D_OUT_4(),
					     .D_OUT_5());

  // rule RL_m_doInit
  assign CAN_FIRE_RL_m_doInit = !m_didInit ;
  assign WILL_FIRE_RL_m_doInit = CAN_FIRE_RL_m_doInit ;

  // rule RL_m_receiveValues
  assign CAN_FIRE_RL_m_receiveValues = MUX_m_readyVec_mem_mem_upd_1__SEL_1 ;
  assign WILL_FIRE_RL_m_receiveValues = MUX_m_readyVec_mem_mem_upd_1__SEL_1 ;

  // rule RL_m_checkOldest
  assign CAN_FIRE_RL_m_checkOldest = m_didInit ;
  assign WILL_FIRE_RL_m_checkOldest = m_didInit ;

  // rule RL_m_bypassOldest
  assign CAN_FIRE_RL_m_bypassOldest =
	     !m_exitValQ_rv[518] && (!m_didInit || !m_oldestIsReady_wget) &&
	     !m_exitEntryIdQ_EMPTY_N &&
	     MUX_m_readyVec_mem_mem_upd_1__SEL_1 &&
	     m_setValueQ_rvport1__read_BITS_517_TO_0__q1[517:512] ==
	     m_nextDeq ;
  assign WILL_FIRE_RL_m_bypassOldest = CAN_FIRE_RL_m_bypassOldest ;

  // rule RL_m_doAllocSlot
  assign CAN_FIRE_RL_m_doAllocSlot = m_didInit && EN_enq ;
  assign WILL_FIRE_RL_m_doAllocSlot = CAN_FIRE_RL_m_doAllocSlot ;

  // rule RL_m_values_enqIntoFIFO
  assign CAN_FIRE_RL_m_values_enqIntoFIFO =
	     m_values_buffer_ff_FULL_N && m_values_readReqMade_ctr ;
  assign WILL_FIRE_RL_m_values_enqIntoFIFO =
	     CAN_FIRE_RL_m_values_enqIntoFIFO ;

  // rule RL_m_readReqOldest
  assign CAN_FIRE_RL_m_readReqOldest =
	     m_values_bufferingAvailable_ctr != 2'd0 &&
	     m_exitEntryIdQ_FULL_N &&
	     m_didInit &&
	     m_oldestIsReady_wget ;
  assign WILL_FIRE_RL_m_readReqOldest = CAN_FIRE_RL_m_readReqOldest ;

  // rule RL_m_readRespOldest
  assign CAN_FIRE_RL_m_readRespOldest =
	     m_values_buffer_firstValid_Q_OUT &&
	     (m_values_buffer_ff_EMPTY_N ||
	      CAN_FIRE_RL_m_values_enqIntoFIFO) &&
	     !m_exitValQ_rv[518] &&
	     m_exitEntryIdQ_EMPTY_N ;
  assign WILL_FIRE_RL_m_readRespOldest = CAN_FIRE_RL_m_readRespOldest ;

  // rule RL_m_nEntries_updateCounter
  assign CAN_FIRE_RL_m_nEntries_updateCounter = 1'd1 ;
  assign WILL_FIRE_RL_m_nEntries_updateCounter = 1'd1 ;

  // rule RL_m_values_buffer_enqueue
  assign CAN_FIRE_RL_m_values_buffer_enqueue =
	     CAN_FIRE_RL_m_values_enqIntoFIFO &&
	     (!CAN_FIRE_RL_m_readRespOldest || m_values_buffer_ff_EMPTY_N) ;
  assign WILL_FIRE_RL_m_values_buffer_enqueue =
	     CAN_FIRE_RL_m_values_buffer_enqueue ;

  // rule RL_m_values_buffer_dequeue
  assign CAN_FIRE_RL_m_values_buffer_dequeue =
	     CAN_FIRE_RL_m_readRespOldest && m_values_buffer_ff_EMPTY_N ;
  assign WILL_FIRE_RL_m_values_buffer_dequeue =
	     CAN_FIRE_RL_m_values_buffer_dequeue ;

  // rule RL_m_values_readReqMade_updateCounter
  assign CAN_FIRE_RL_m_values_readReqMade_updateCounter = 1'd1 ;
  assign WILL_FIRE_RL_m_values_readReqMade_updateCounter = 1'd1 ;

  // rule RL_m_values_bufferingAvailable_updateCounter
  assign CAN_FIRE_RL_m_values_bufferingAvailable_updateCounter = 1'd1 ;
  assign WILL_FIRE_RL_m_values_bufferingAvailable_updateCounter = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_m_readyVec_mem_mem_upd_1__SEL_1 =
	     m_setValueQ_rv_port1__read[518] && m_didInit ;
  assign MUX_m_exitValQ_rv_port0__write_1__VAL_1 =
	     { 1'd1,
	       m_setValueQ_rvport1__read_BITS_517_TO_0__q1[511:0],
	       m_nextDeq } ;
  assign MUX_m_exitValQ_rv_port0__write_1__VAL_2 =
	     { 1'd1, x__h4237, m_exitEntryIdQ_D_OUT } ;

  // inlined wires
  assign m_nEntries_downByW_whas =
	     WILL_FIRE_RL_m_readReqOldest || WILL_FIRE_RL_m_bypassOldest ;
  assign m_oldestIsReady_wget =
	     m_nEntries_ctr != 7'd0 &&
	     m_reqVec_mem_mem_D_OUT_2 == m_readyVec_mem_mem_D_OUT_1 ;
  assign m_exitValQ_rv_EN_port0__write =
	     WILL_FIRE_RL_m_bypassOldest || WILL_FIRE_RL_m_readRespOldest ;
  assign m_exitValQ_rv_port0__write_1 =
	     WILL_FIRE_RL_m_bypassOldest ?
	       MUX_m_exitValQ_rv_port0__write_1__VAL_1 :
	       MUX_m_exitValQ_rv_port0__write_1__VAL_2 ;
  assign m_exitValQ_rv_port1__read =
	     m_exitValQ_rv_EN_port0__write ?
	       m_exitValQ_rv_port0__write_1 :
	       m_exitValQ_rv ;
  assign m_exitValQ_rv_port2__read =
	     EN_deq ?
	       519'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA :
	       m_exitValQ_rv_port1__read ;
  assign m_setValueQ_rv_port0__write_1 =
	     { 1'd1, setValue_id, setValue_data } ;
  assign m_setValueQ_rv_port1__read =
	     EN_setValue ? m_setValueQ_rv_port0__write_1 : m_setValueQ_rv ;
  assign m_setValueQ_rv_port2__read =
	     MUX_m_readyVec_mem_mem_upd_1__SEL_1 ?
	       519'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA :
	       m_setValueQ_rv_port1__read ;

  // register m_didInit
  assign m_didInit_D_IN = 1'd1 ;
  assign m_didInit_EN = WILL_FIRE_RL_m_doInit && m_initIdx == 6'd63 ;

  // register m_exitValQ_rv
  assign m_exitValQ_rv_D_IN = m_exitValQ_rv_port2__read ;
  assign m_exitValQ_rv_EN = 1'b1 ;

  // register m_initIdx
  assign m_initIdx_D_IN = m_initIdx + 6'd1 ;
  assign m_initIdx_EN = CAN_FIRE_RL_m_doInit ;

  // register m_nEntries_ctr
  assign m_nEntries_ctr_D_IN = new_value__h408 ;
  assign m_nEntries_ctr_EN = 1'd1 ;

  // register m_nEntries_zero
  assign m_nEntries_zero_D_IN = new_value__h408 == 7'd0 ;
  assign m_nEntries_zero_EN = 1'd1 ;

  // register m_nextDeq
  assign m_nextDeq_D_IN = m_nextDeq + 6'd1 ;
  assign m_nextDeq_EN = m_nEntries_downByW_whas ;

  // register m_nextEnq
  assign m_nextEnq_D_IN = m_nextEnq + 6'd1 ;
  assign m_nextEnq_EN = EN_enq ;

  // register m_setValueQ_rv
  assign m_setValueQ_rv_D_IN = m_setValueQ_rv_port2__read ;
  assign m_setValueQ_rv_EN = 1'b1 ;

  // register m_values_bufferingAvailable_ctr
  assign m_values_bufferingAvailable_ctr_D_IN = new_value__h1869 ;
  assign m_values_bufferingAvailable_ctr_EN = 1'd1 ;

  // register m_values_bufferingAvailable_zero
  assign m_values_bufferingAvailable_zero_D_IN = new_value__h1869 == 2'd0 ;
  assign m_values_bufferingAvailable_zero_EN = 1'd1 ;

  // register m_values_ram_mem_outputR
  assign m_values_ram_mem_outputR_D_IN = m_values_ram_mem_ram_D_OUT_1 ;
  assign m_values_ram_mem_outputR_EN = CAN_FIRE_RL_m_readReqOldest ;

  // register m_values_readReqMade_ctr
  assign m_values_readReqMade_ctr_D_IN = new_value__h1444 ;
  assign m_values_readReqMade_ctr_EN = 1'd1 ;

  // register m_values_readReqMade_zero
  assign m_values_readReqMade_zero_D_IN = !new_value__h1444 ;
  assign m_values_readReqMade_zero_EN = 1'd1 ;

  // submodule m_exitEntryIdQ
  assign m_exitEntryIdQ_D_IN = m_nextDeq ;
  assign m_exitEntryIdQ_ENQ = CAN_FIRE_RL_m_readReqOldest ;
  assign m_exitEntryIdQ_DEQ = CAN_FIRE_RL_m_readRespOldest ;
  assign m_exitEntryIdQ_CLR = 1'b0 ;

  // submodule m_readyVec_mem_mem
  assign m_readyVec_mem_mem_ADDR_1 = m_nextDeq ;
  assign m_readyVec_mem_mem_ADDR_2 = 6'h0 ;
  assign m_readyVec_mem_mem_ADDR_3 = 6'h0 ;
  assign m_readyVec_mem_mem_ADDR_4 = 6'h0 ;
  assign m_readyVec_mem_mem_ADDR_5 = 6'h0 ;
  assign m_readyVec_mem_mem_ADDR_IN =
	     WILL_FIRE_RL_m_receiveValues ?
	       m_setValueQ_rv_port1__read[517:512] :
	       m_initIdx ;
  assign m_readyVec_mem_mem_D_IN =
	     WILL_FIRE_RL_m_receiveValues && m_reqVec_mem_mem_D_OUT_3 ;
  assign m_readyVec_mem_mem_WE =
	     WILL_FIRE_RL_m_receiveValues || WILL_FIRE_RL_m_doInit ;

  // submodule m_reqVec_mem_mem
  assign m_reqVec_mem_mem_ADDR_1 = m_nextEnq ;
  assign m_reqVec_mem_mem_ADDR_2 = m_nextDeq ;
  assign m_reqVec_mem_mem_ADDR_3 = m_setValueQ_rv_port1__read[517:512] ;
  assign m_reqVec_mem_mem_ADDR_4 = 6'h0 ;
  assign m_reqVec_mem_mem_ADDR_5 = 6'h0 ;
  assign m_reqVec_mem_mem_ADDR_IN =
	     WILL_FIRE_RL_m_doAllocSlot ? m_nextEnq : m_initIdx ;
  assign m_reqVec_mem_mem_D_IN =
	     WILL_FIRE_RL_m_doAllocSlot && !m_reqVec_mem_mem_D_OUT_1 ;
  assign m_reqVec_mem_mem_WE =
	     WILL_FIRE_RL_m_doAllocSlot || WILL_FIRE_RL_m_doInit ;

  // submodule m_values_buffer_ff
  assign m_values_buffer_ff_D_IN = m_values_ram_mem_outputR ;
  assign m_values_buffer_ff_ENQ = CAN_FIRE_RL_m_values_buffer_enqueue ;
  assign m_values_buffer_ff_DEQ = CAN_FIRE_RL_m_values_buffer_dequeue ;
  assign m_values_buffer_ff_CLR = 1'b0 ;

  // submodule m_values_buffer_firstValid
  assign m_values_buffer_firstValid_D_IN = 1'd1 ;
  assign m_values_buffer_firstValid_EN = CAN_FIRE_RL_m_readRespOldest ;

  // submodule m_values_ram_mem_ram
  assign m_values_ram_mem_ram_ADDR_1 = m_nextDeq ;
  assign m_values_ram_mem_ram_ADDR_2 = 6'h0 ;
  assign m_values_ram_mem_ram_ADDR_3 = 6'h0 ;
  assign m_values_ram_mem_ram_ADDR_4 = 6'h0 ;
  assign m_values_ram_mem_ram_ADDR_5 = 6'h0 ;
  assign m_values_ram_mem_ram_ADDR_IN = m_setValueQ_rv_port1__read[517:512] ;
  assign m_values_ram_mem_ram_D_IN = m_setValueQ_rv_port1__read[511:0] ;
  assign m_values_ram_mem_ram_WE = MUX_m_readyVec_mem_mem_upd_1__SEL_1 ;

  // remaining internal signals
  assign m_setValueQ_rvport1__read_BITS_517_TO_0__q1 =
	     m_setValueQ_rv_port1__read[517:0] ;
  assign new_value__h1444 = x__h1461 - CAN_FIRE_RL_m_values_enqIntoFIFO ;
  assign new_value__h1869 = x__h1886 - y__h1855 ;
  assign new_value__h408 = x__h425 - y__h394 ;
  assign x__h1461 = m_values_readReqMade_ctr + CAN_FIRE_RL_m_readReqOldest ;
  assign x__h1886 = m_values_bufferingAvailable_ctr + y__h1857 ;
  assign x__h4237 =
	     m_values_buffer_ff_EMPTY_N ?
	       m_values_buffer_ff_D_OUT :
	       m_values_ram_mem_outputR ;
  assign x__h425 = m_nEntries_ctr + y__h396 ;
  assign y__h1855 = CAN_FIRE_RL_m_readReqOldest ? 2'd1 : 2'd0 ;
  assign y__h1857 = CAN_FIRE_RL_m_readRespOldest ? 2'd1 : 2'd0 ;
  assign y__h394 = m_nEntries_downByW_whas ? 7'd1 : 7'd0 ;
  assign y__h396 = EN_enq ? 7'd1 : 7'd0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        m_didInit <= `BSV_ASSIGNMENT_DELAY 1'd0;
	m_exitValQ_rv <= `BSV_ASSIGNMENT_DELAY
	    519'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
	m_initIdx <= `BSV_ASSIGNMENT_DELAY 6'd0;
	m_nEntries_ctr <= `BSV_ASSIGNMENT_DELAY 7'd0;
	m_nEntries_zero <= `BSV_ASSIGNMENT_DELAY 1'd1;
	m_nextDeq <= `BSV_ASSIGNMENT_DELAY 6'd0;
	m_nextEnq <= `BSV_ASSIGNMENT_DELAY 6'd0;
	m_setValueQ_rv <= `BSV_ASSIGNMENT_DELAY
	    519'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
	m_values_bufferingAvailable_ctr <= `BSV_ASSIGNMENT_DELAY 2'd2;
	m_values_bufferingAvailable_zero <= `BSV_ASSIGNMENT_DELAY 1'd0;
	m_values_readReqMade_ctr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	m_values_readReqMade_zero <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (m_didInit_EN) m_didInit <= `BSV_ASSIGNMENT_DELAY m_didInit_D_IN;
	if (m_exitValQ_rv_EN)
	  m_exitValQ_rv <= `BSV_ASSIGNMENT_DELAY m_exitValQ_rv_D_IN;
	if (m_initIdx_EN) m_initIdx <= `BSV_ASSIGNMENT_DELAY m_initIdx_D_IN;
	if (m_nEntries_ctr_EN)
	  m_nEntries_ctr <= `BSV_ASSIGNMENT_DELAY m_nEntries_ctr_D_IN;
	if (m_nEntries_zero_EN)
	  m_nEntries_zero <= `BSV_ASSIGNMENT_DELAY m_nEntries_zero_D_IN;
	if (m_nextDeq_EN) m_nextDeq <= `BSV_ASSIGNMENT_DELAY m_nextDeq_D_IN;
	if (m_nextEnq_EN) m_nextEnq <= `BSV_ASSIGNMENT_DELAY m_nextEnq_D_IN;
	if (m_setValueQ_rv_EN)
	  m_setValueQ_rv <= `BSV_ASSIGNMENT_DELAY m_setValueQ_rv_D_IN;
	if (m_values_bufferingAvailable_ctr_EN)
	  m_values_bufferingAvailable_ctr <= `BSV_ASSIGNMENT_DELAY
	      m_values_bufferingAvailable_ctr_D_IN;
	if (m_values_bufferingAvailable_zero_EN)
	  m_values_bufferingAvailable_zero <= `BSV_ASSIGNMENT_DELAY
	      m_values_bufferingAvailable_zero_D_IN;
	if (m_values_readReqMade_ctr_EN)
	  m_values_readReqMade_ctr <= `BSV_ASSIGNMENT_DELAY
	      m_values_readReqMade_ctr_D_IN;
	if (m_values_readReqMade_zero_EN)
	  m_values_readReqMade_zero <= `BSV_ASSIGNMENT_DELAY
	      m_values_readReqMade_zero_D_IN;
      end
    if (m_values_ram_mem_outputR_EN)
      m_values_ram_mem_outputR <= `BSV_ASSIGNMENT_DELAY
	  m_values_ram_mem_outputR_D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    m_didInit = 1'h0;
    m_exitValQ_rv =
	519'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    m_initIdx = 6'h2A;
    m_nEntries_ctr = 7'h2A;
    m_nEntries_zero = 1'h0;
    m_nextDeq = 6'h2A;
    m_nextEnq = 6'h2A;
    m_setValueQ_rv =
	519'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    m_values_bufferingAvailable_ctr = 2'h2;
    m_values_bufferingAvailable_zero = 1'h0;
    m_values_ram_mem_outputR =
	512'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    m_values_readReqMade_ctr = 1'h0;
    m_values_readReqMade_zero = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkBRAMScoreboardQPI

