//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Wed Sep 17 21:53:18 EDT 2014
//
// BVI format method schedule info:
// schedule enq  CF ( notEmpty );
// schedule enq  SBR ( clear );
// schedule enq  C ( enq );
//
// schedule deq  CF ( notEmpty );
// schedule deq  SBR ( enq, notFull, clear );
// schedule deq  C ( deq );
//
// schedule first  CF ( first, notFull, notEmpty );
// schedule first  SB ( enq, deq, clear );
//
// schedule notFull  CF ( first, notFull, notEmpty );
// schedule notFull  SB ( enq, clear );
//
// schedule notEmpty  CF ( enq, deq, first, notFull, notEmpty, clear );
//
// schedule clear  CF ( notEmpty );
// schedule clear  C ( clear );
//
//
// Ports:
// Name                         I/O  size props
// RDY_enq                        O     1
// RDY_deq                        O     1 reg
// first                          O   512 reg
// RDY_first                      O     1 reg
// notFull                        O     1
// RDY_notFull                    O     1 const
// notEmpty                       O     1 reg
// RDY_notEmpty                   O     1 const
// RDY_clear                      O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// enq_fifoData                   I   128 reg
// EN_enq                         I     1
// EN_deq                         I     1
// EN_clear                       I     1
//
// Combinational paths from inputs to outputs:
//   EN_deq -> RDY_enq
//   EN_deq -> notFull
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkDemarshallerHighToLowQA(CLK,
				  RST_N,

				  enq_fifoData,
				  EN_enq,
				  RDY_enq,

				  EN_deq,
				  RDY_deq,

				  first,
				  RDY_first,

				  notFull,
				  RDY_notFull,

				  notEmpty,
				  RDY_notEmpty,

				  EN_clear,
				  RDY_clear);
  input  CLK;
  input  RST_N;

  // action method enq
  input  [127 : 0] enq_fifoData;
  input  EN_enq;
  output RDY_enq;

  // action method deq
  input  EN_deq;
  output RDY_deq;

  // value method first
  output [511 : 0] first;
  output RDY_first;

  // value method notFull
  output notFull;
  output RDY_notFull;

  // value method notEmpty
  output notEmpty;
  output RDY_notEmpty;

  // action method clear
  input  EN_clear;
  output RDY_clear;

  // signals for module outputs
  wire [511 : 0] first;
  wire RDY_clear,
       RDY_deq,
       RDY_enq,
       RDY_first,
       RDY_notEmpty,
       RDY_notFull,
       notEmpty,
       notFull;

  // inlined wires
  wire m_m_enqComplete_whas;

  // register m_m_buffer
  reg [383 : 0] m_m_buffer;
  wire [383 : 0] m_m_buffer_D_IN;
  wire m_m_buffer_EN;

  // register m_m_count
  reg [1 : 0] m_m_count;
  wire [1 : 0] m_m_count_D_IN;
  wire m_m_count_EN;

  // register m_m_full
  reg m_m_full;
  wire m_m_full_D_IN, m_m_full_EN;

  // ports of submodule m_m_entry0Q
  wire [127 : 0] m_m_entry0Q_D_IN, m_m_entry0Q_D_OUT;
  wire m_m_entry0Q_CLR, m_m_entry0Q_DEQ, m_m_entry0Q_ENQ, m_m_entry0Q_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_m_m_updateFull,
       CAN_FIRE_clear,
       CAN_FIRE_deq,
       CAN_FIRE_enq,
       WILL_FIRE_RL_m_m_updateFull,
       WILL_FIRE_clear,
       WILL_FIRE_deq,
       WILL_FIRE_enq;

  // inputs to muxes for submodule ports
  wire [1 : 0] MUX_m_m_count_write_1__VAL_2;

  // action method enq
  assign RDY_enq = notFull ;
  assign CAN_FIRE_enq = notFull ;
  assign WILL_FIRE_enq = EN_enq ;

  // action method deq
  assign RDY_deq = m_m_full ;
  assign CAN_FIRE_deq = m_m_full ;
  assign WILL_FIRE_deq = EN_deq ;

  // value method first
  assign first = { m_m_buffer, m_m_entry0Q_D_OUT } ;
  assign RDY_first = m_m_full ;

  // value method notFull
  assign notFull = !m_m_full || m_m_entry0Q_FULL_N ;
  assign RDY_notFull = 1'd1 ;

  // value method notEmpty
  assign notEmpty = m_m_full ;
  assign RDY_notEmpty = 1'd1 ;

  // action method clear
  assign RDY_clear = 1'd1 ;
  assign CAN_FIRE_clear = 1'd1 ;
  assign WILL_FIRE_clear = EN_clear ;

  // submodule m_m_entry0Q
  FIFOL1 #(.width(32'd128)) m_m_entry0Q(.RST(RST_N),
					.CLK(CLK),
					.D_IN(m_m_entry0Q_D_IN),
					.ENQ(m_m_entry0Q_ENQ),
					.DEQ(m_m_entry0Q_DEQ),
					.CLR(m_m_entry0Q_CLR),
					.D_OUT(m_m_entry0Q_D_OUT),
					.FULL_N(m_m_entry0Q_FULL_N),
					.EMPTY_N());

  // rule RL_m_m_updateFull
  assign CAN_FIRE_RL_m_m_updateFull = 1'd1 ;
  assign WILL_FIRE_RL_m_m_updateFull = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_m_m_count_write_1__VAL_2 =
	     (m_m_count == 2'd3) ? 2'd0 : m_m_count + 2'd1 ;

  // inlined wires
  assign m_m_enqComplete_whas = EN_enq && m_m_count == 2'd3 ;

  // register m_m_buffer
  assign m_m_buffer_D_IN = { enq_fifoData, m_m_buffer[383:128] } ;
  assign m_m_buffer_EN = EN_enq && m_m_count != 2'd0 ;

  // register m_m_count
  assign m_m_count_D_IN = EN_clear ? 2'd0 : MUX_m_m_count_write_1__VAL_2 ;
  assign m_m_count_EN = EN_enq || EN_clear ;

  // register m_m_full
  assign m_m_full_D_IN =
	     (m_m_full ^ EN_deq || m_m_enqComplete_whas) && !EN_clear ;
  assign m_m_full_EN = 1'd1 ;

  // submodule m_m_entry0Q
  assign m_m_entry0Q_D_IN = enq_fifoData ;
  assign m_m_entry0Q_ENQ = EN_enq && m_m_count == 2'd0 ;
  assign m_m_entry0Q_DEQ = EN_deq ;
  assign m_m_entry0Q_CLR = EN_clear ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        m_m_count <= `BSV_ASSIGNMENT_DELAY 2'd0;
	m_m_full <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (m_m_count_EN) m_m_count <= `BSV_ASSIGNMENT_DELAY m_m_count_D_IN;
	if (m_m_full_EN) m_m_full <= `BSV_ASSIGNMENT_DELAY m_m_full_D_IN;
      end
    if (m_m_buffer_EN) m_m_buffer <= `BSV_ASSIGNMENT_DELAY m_m_buffer_D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    m_m_buffer =
	384'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    m_m_count = 2'h2;
    m_m_full = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkDemarshallerHighToLowQA

