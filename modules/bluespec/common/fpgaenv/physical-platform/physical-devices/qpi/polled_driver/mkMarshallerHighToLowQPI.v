//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Wed Sep 17 21:53:18 EDT 2014
//
// BVI format method schedule info:
// schedule enq  CF ( first, notFull, notEmpty, isLast );
// schedule enq  C ( enq );
//
// schedule deq  SBR ( enq, notFull );
// schedule deq  C ( deq );
//
// schedule first  CF ( enq, first, notFull, notEmpty, isLast );
// schedule first  SB ( deq );
//
// schedule notFull  CF ( enq, first, notFull, notEmpty, isLast );
//
// schedule notEmpty  CF ( enq, first, notFull, notEmpty, isLast );
// schedule notEmpty  SB ( deq );
//
// schedule isLast  CF ( enq, first, notFull, notEmpty, isLast );
// schedule isLast  SB ( deq );
//
//
// Ports:
// Name                         I/O  size props
// RDY_enq                        O     1
// RDY_deq                        O     1 reg
// first                          O   128 reg
// RDY_first                      O     1 reg
// notFull                        O     1
// RDY_notFull                    O     1 const
// notEmpty                       O     1 reg
// RDY_notEmpty                   O     1 const
// isLast                         O     1 reg
// RDY_isLast                     O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// enq_inData                     I   512
// EN_enq                         I     1
// EN_deq                         I     1
//
// Combinational paths from inputs to outputs:
//   EN_deq -> RDY_enq
//   EN_deq -> notFull
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMarshallerHighToLowQPI(CLK,
				RST_N,

				enq_inData,
				EN_enq,
				RDY_enq,

				EN_deq,
				RDY_deq,

				first,
				RDY_first,

				notFull,
				RDY_notFull,

				notEmpty,
				RDY_notEmpty,

				isLast,
				RDY_isLast);
  input  CLK;
  input  RST_N;

  // action method enq
  input  [511 : 0] enq_inData;
  input  EN_enq;
  output RDY_enq;

  // action method deq
  input  EN_deq;
  output RDY_deq;

  // value method first
  output [127 : 0] first;
  output RDY_first;

  // value method notFull
  output notFull;
  output RDY_notFull;

  // value method notEmpty
  output notEmpty;
  output RDY_notEmpty;

  // value method isLast
  output isLast;
  output RDY_isLast;

  // signals for module outputs
  wire [127 : 0] first;
  wire RDY_deq,
       RDY_enq,
       RDY_first,
       RDY_isLast,
       RDY_notEmpty,
       RDY_notFull,
       isLast,
       notEmpty,
       notFull;

  // inlined wires
  wire [514 : 0] m_m_incomingData_wget;

  // register m_m_buffer
  reg [383 : 0] m_m_buffer;
  wire [383 : 0] m_m_buffer_D_IN;
  wire m_m_buffer_EN;

  // register m_m_count
  reg [2 : 0] m_m_count;
  wire [2 : 0] m_m_count_D_IN;
  wire m_m_count_EN;

  // register m_m_empty
  reg m_m_empty;
  wire m_m_empty_D_IN, m_m_empty_EN;

  // ports of submodule m_m_outQ
  wire [128 : 0] m_m_outQ_D_IN, m_m_outQ_D_OUT;
  wire m_m_outQ_CLR,
       m_m_outQ_DEQ,
       m_m_outQ_EMPTY_N,
       m_m_outQ_ENQ,
       m_m_outQ_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_m_m_incoming,
       CAN_FIRE_RL_m_m_marshaller,
       CAN_FIRE_deq,
       CAN_FIRE_enq,
       WILL_FIRE_RL_m_m_incoming,
       WILL_FIRE_RL_m_m_marshaller,
       WILL_FIRE_deq,
       WILL_FIRE_enq;

  // inputs to muxes for submodule ports
  wire [383 : 0] MUX_m_m_buffer_write_1__VAL_2;
  wire [128 : 0] MUX_m_m_outQ_enq_1__VAL_1, MUX_m_m_outQ_enq_1__VAL_2;
  wire [2 : 0] MUX_m_m_count_write_1__VAL_1, MUX_m_m_count_write_1__VAL_2;

  // remaining internal signals
  wire [514 : 0] ab__h407;

  // action method enq
  assign RDY_enq = notFull ;
  assign CAN_FIRE_enq = notFull ;
  assign WILL_FIRE_enq = EN_enq ;

  // action method deq
  assign RDY_deq = m_m_outQ_EMPTY_N ;
  assign CAN_FIRE_deq = m_m_outQ_EMPTY_N ;
  assign WILL_FIRE_deq = EN_deq ;

  // value method first
  assign first = m_m_outQ_D_OUT[128:1] ;
  assign RDY_first = m_m_outQ_EMPTY_N ;

  // value method notFull
  assign notFull = m_m_empty && m_m_outQ_FULL_N ;
  assign RDY_notFull = 1'd1 ;

  // value method notEmpty
  assign notEmpty = m_m_outQ_EMPTY_N ;
  assign RDY_notEmpty = 1'd1 ;

  // value method isLast
  assign isLast = m_m_outQ_D_OUT[0] ;
  assign RDY_isLast = m_m_outQ_EMPTY_N ;

  // submodule m_m_outQ
  FIFOL1 #(.width(32'd129)) m_m_outQ(.RST(RST_N),
				     .CLK(CLK),
				     .D_IN(m_m_outQ_D_IN),
				     .ENQ(m_m_outQ_ENQ),
				     .DEQ(m_m_outQ_DEQ),
				     .CLR(m_m_outQ_CLR),
				     .D_OUT(m_m_outQ_D_OUT),
				     .FULL_N(m_m_outQ_FULL_N),
				     .EMPTY_N(m_m_outQ_EMPTY_N));

  // rule RL_m_m_incoming
  assign CAN_FIRE_RL_m_m_incoming = m_m_empty && EN_enq ;
  assign WILL_FIRE_RL_m_m_incoming = CAN_FIRE_RL_m_m_incoming ;

  // rule RL_m_m_marshaller
  assign CAN_FIRE_RL_m_m_marshaller = !m_m_empty && m_m_outQ_FULL_N ;
  assign WILL_FIRE_RL_m_m_marshaller = CAN_FIRE_RL_m_m_marshaller ;

  // inputs to muxes for submodule ports
  assign MUX_m_m_buffer_write_1__VAL_2 =
	     { 128'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, m_m_buffer[383:128] } ;
  assign MUX_m_m_count_write_1__VAL_1 = ab__h407[2:0] - 3'd1 ;
  assign MUX_m_m_count_write_1__VAL_2 = m_m_count - 3'd1 ;
  assign MUX_m_m_outQ_enq_1__VAL_1 =
	     { ab__h407[130:3], ab__h407[2:0] == 3'd1 } ;
  assign MUX_m_m_outQ_enq_1__VAL_2 =
	     { m_m_buffer[127:0], m_m_count == 3'd1 } ;

  // inlined wires
  assign m_m_incomingData_wget = { enq_inData, 3'd4 } ;

  // register m_m_buffer
  assign m_m_buffer_D_IN =
	     WILL_FIRE_RL_m_m_incoming ?
	       ab__h407[514:131] :
	       MUX_m_m_buffer_write_1__VAL_2 ;
  assign m_m_buffer_EN =
	     WILL_FIRE_RL_m_m_incoming || WILL_FIRE_RL_m_m_marshaller ;

  // register m_m_count
  assign m_m_count_D_IN =
	     WILL_FIRE_RL_m_m_incoming ?
	       MUX_m_m_count_write_1__VAL_1 :
	       MUX_m_m_count_write_1__VAL_2 ;
  assign m_m_count_EN =
	     WILL_FIRE_RL_m_m_incoming || WILL_FIRE_RL_m_m_marshaller ;

  // register m_m_empty
  assign m_m_empty_D_IN =
	     WILL_FIRE_RL_m_m_incoming ?
	       ab__h407[2:0] == 3'd1 :
	       m_m_count == 3'd1 ;
  assign m_m_empty_EN =
	     WILL_FIRE_RL_m_m_incoming || WILL_FIRE_RL_m_m_marshaller ;

  // submodule m_m_outQ
  assign m_m_outQ_D_IN =
	     WILL_FIRE_RL_m_m_incoming ?
	       MUX_m_m_outQ_enq_1__VAL_1 :
	       MUX_m_m_outQ_enq_1__VAL_2 ;
  assign m_m_outQ_ENQ =
	     WILL_FIRE_RL_m_m_incoming || WILL_FIRE_RL_m_m_marshaller ;
  assign m_m_outQ_DEQ = EN_deq ;
  assign m_m_outQ_CLR = 1'b0 ;

  // remaining internal signals
  assign ab__h407 = m_m_incomingData_wget ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        m_m_count <= `BSV_ASSIGNMENT_DELAY 3'd0;
	m_m_empty <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (m_m_count_EN) m_m_count <= `BSV_ASSIGNMENT_DELAY m_m_count_D_IN;
	if (m_m_empty_EN) m_m_empty <= `BSV_ASSIGNMENT_DELAY m_m_empty_D_IN;
      end
    if (m_m_buffer_EN) m_m_buffer <= `BSV_ASSIGNMENT_DELAY m_m_buffer_D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    m_m_buffer =
	384'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    m_m_count = 3'h2;
    m_m_empty = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMarshallerHighToLowQPI

