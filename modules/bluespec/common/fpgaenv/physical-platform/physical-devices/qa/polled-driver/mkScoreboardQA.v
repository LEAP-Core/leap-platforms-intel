//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Wed Sep 17 21:54:19 EDT 2014
//
// BVI format method schedule info:
// schedule enq  CF ( setValue, first, deq, notFull, notEmpty, deqEntryId );
// schedule enq  C ( enq );
//
// schedule setValue  CF ( enq, first, deq, notFull, notEmpty, deqEntryId );
// schedule setValue  C ( setValue );
//
// schedule first  CF ( enq, setValue, first, notFull, notEmpty, deqEntryId );
// schedule first  SB ( deq );
//
// schedule deq  CF ( enq, setValue, notFull, notEmpty );
// schedule deq  C ( deq );
//
// schedule notFull  CF ( enq,
// 		       setValue,
// 		       first,
// 		       deq,
// 		       notFull,
// 		       notEmpty,
// 		       deqEntryId );
//
// schedule notEmpty  CF ( enq,
// 			setValue,
// 			first,
// 			deq,
// 			notFull,
// 			notEmpty,
// 			deqEntryId );
//
// schedule deqEntryId  CF ( enq,
// 			  setValue,
// 			  first,
// 			  notFull,
// 			  notEmpty,
// 			  deqEntryId );
// schedule deqEntryId  SB ( deq );
//
//
// Ports:
// Name                         I/O  size props
// enq                            O     6 reg
// RDY_enq                        O     1
// RDY_setValue                   O     1 const
// first                          O   512
// RDY_first                      O     1
// RDY_deq                        O     1
// notFull                        O     1
// RDY_notFull                    O     1 const
// notEmpty                       O     1
// RDY_notEmpty                   O     1 const
// deqEntryId                     O     6 reg
// RDY_deqEntryId                 O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// setValue_id                    I     6
// setValue_data                  I   512 reg
// EN_setValue                    I     1
// EN_deq                         I     1
// EN_enq                         I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkScoreboardQA(CLK,
		       RST_N,

		       EN_enq,
		       enq,
		       RDY_enq,

		       setValue_id,
		       setValue_data,
		       EN_setValue,
		       RDY_setValue,

		       first,
		       RDY_first,

		       EN_deq,
		       RDY_deq,

		       notFull,
		       RDY_notFull,

		       notEmpty,
		       RDY_notEmpty,

		       deqEntryId,
		       RDY_deqEntryId);
  input  CLK;
  input  RST_N;

  // actionvalue method enq
  input  EN_enq;
  output [5 : 0] enq;
  output RDY_enq;

  // action method setValue
  input  [5 : 0] setValue_id;
  input  [511 : 0] setValue_data;
  input  EN_setValue;
  output RDY_setValue;

  // value method first
  output [511 : 0] first;
  output RDY_first;

  // action method deq
  input  EN_deq;
  output RDY_deq;

  // value method notFull
  output notFull;
  output RDY_notFull;

  // value method notEmpty
  output notEmpty;
  output RDY_notEmpty;

  // value method deqEntryId
  output [5 : 0] deqEntryId;
  output RDY_deqEntryId;

  // signals for module outputs
  wire [511 : 0] first;
  wire [5 : 0] deqEntryId, enq;
  wire RDY_deq,
       RDY_deqEntryId,
       RDY_enq,
       RDY_first,
       RDY_notEmpty,
       RDY_notFull,
       RDY_setValue,
       notEmpty,
       notFull;

  // inlined wires
  wire m_oldestIsReady_wget;

  // register m_didInit
  reg m_didInit;
  wire m_didInit_D_IN, m_didInit_EN;

  // register m_initIdx
  reg [5 : 0] m_initIdx;
  wire [5 : 0] m_initIdx_D_IN;
  wire m_initIdx_EN;

  // register m_nEntries_ctr
  reg [6 : 0] m_nEntries_ctr;
  wire [6 : 0] m_nEntries_ctr_D_IN;
  wire m_nEntries_ctr_EN;

  // register m_nEntries_zero
  reg m_nEntries_zero;
  wire m_nEntries_zero_D_IN, m_nEntries_zero_EN;

  // register m_nextDeq
  reg [5 : 0] m_nextDeq;
  wire [5 : 0] m_nextDeq_D_IN;
  wire m_nextDeq_EN;

  // register m_nextEnq
  reg [5 : 0] m_nextEnq;
  wire [5 : 0] m_nextEnq_D_IN;
  wire m_nextEnq_EN;

  // ports of submodule m_readyVec_mem_mem
  wire [5 : 0] m_readyVec_mem_mem_ADDR_1,
	       m_readyVec_mem_mem_ADDR_2,
	       m_readyVec_mem_mem_ADDR_3,
	       m_readyVec_mem_mem_ADDR_4,
	       m_readyVec_mem_mem_ADDR_5,
	       m_readyVec_mem_mem_ADDR_IN;
  wire m_readyVec_mem_mem_D_IN,
       m_readyVec_mem_mem_D_OUT_1,
       m_readyVec_mem_mem_WE;

  // ports of submodule m_reqVec_mem_mem
  wire [5 : 0] m_reqVec_mem_mem_ADDR_1,
	       m_reqVec_mem_mem_ADDR_2,
	       m_reqVec_mem_mem_ADDR_3,
	       m_reqVec_mem_mem_ADDR_4,
	       m_reqVec_mem_mem_ADDR_5,
	       m_reqVec_mem_mem_ADDR_IN;
  wire m_reqVec_mem_mem_D_IN,
       m_reqVec_mem_mem_D_OUT_1,
       m_reqVec_mem_mem_D_OUT_2,
       m_reqVec_mem_mem_D_OUT_3,
       m_reqVec_mem_mem_WE;

  // ports of submodule m_values_mem_mem
  wire [511 : 0] m_values_mem_mem_D_IN, m_values_mem_mem_D_OUT_1;
  wire [5 : 0] m_values_mem_mem_ADDR_1,
	       m_values_mem_mem_ADDR_2,
	       m_values_mem_mem_ADDR_3,
	       m_values_mem_mem_ADDR_4,
	       m_values_mem_mem_ADDR_5,
	       m_values_mem_mem_ADDR_IN;
  wire m_values_mem_mem_WE;

  // rule scheduling signals
  wire CAN_FIRE_RL_m_checkOldest,
       CAN_FIRE_RL_m_doAllocSlot,
       CAN_FIRE_RL_m_doInit,
       CAN_FIRE_RL_m_nEntries_updateCounter,
       CAN_FIRE_RL_m_valueReady,
       CAN_FIRE_deq,
       CAN_FIRE_enq,
       CAN_FIRE_setValue,
       WILL_FIRE_RL_m_checkOldest,
       WILL_FIRE_RL_m_doAllocSlot,
       WILL_FIRE_RL_m_doInit,
       WILL_FIRE_RL_m_nEntries_updateCounter,
       WILL_FIRE_RL_m_valueReady,
       WILL_FIRE_deq,
       WILL_FIRE_enq,
       WILL_FIRE_setValue;

  // remaining internal signals
  wire [6 : 0] new_value__h405, x__h422, y__h391, y__h393;

  // actionvalue method enq
  assign enq = m_nextEnq ;
  assign RDY_enq = m_didInit && m_nEntries_ctr != 7'd64 ;
  assign CAN_FIRE_enq = m_didInit && m_nEntries_ctr != 7'd64 ;
  assign WILL_FIRE_enq = EN_enq ;

  // action method setValue
  assign RDY_setValue = 1'd1 ;
  assign CAN_FIRE_setValue = 1'd1 ;
  assign WILL_FIRE_setValue = EN_setValue ;

  // value method first
  assign first = m_values_mem_mem_D_OUT_1 ;
  assign RDY_first = RDY_deq ;

  // action method deq
  assign RDY_deq = m_didInit && m_oldestIsReady_wget ;
  assign CAN_FIRE_deq = RDY_deq ;
  assign WILL_FIRE_deq = EN_deq ;

  // value method notFull
  assign notFull = m_nEntries_ctr != 7'd64 ;
  assign RDY_notFull = 1'd1 ;

  // value method notEmpty
  assign notEmpty = m_nEntries_ctr != 7'd0 ;
  assign RDY_notEmpty = 1'd1 ;

  // value method deqEntryId
  assign deqEntryId = m_nextDeq ;
  assign RDY_deqEntryId = 1'd1 ;

  // submodule m_readyVec_mem_mem
  RegFile #(.addr_width(32'd6),
	    .data_width(32'd1),
	    .lo(6'h0),
	    .hi(6'd63)) m_readyVec_mem_mem(.CLK(CLK),
					   .ADDR_1(m_readyVec_mem_mem_ADDR_1),
					   .ADDR_2(m_readyVec_mem_mem_ADDR_2),
					   .ADDR_3(m_readyVec_mem_mem_ADDR_3),
					   .ADDR_4(m_readyVec_mem_mem_ADDR_4),
					   .ADDR_5(m_readyVec_mem_mem_ADDR_5),
					   .ADDR_IN(m_readyVec_mem_mem_ADDR_IN),
					   .D_IN(m_readyVec_mem_mem_D_IN),
					   .WE(m_readyVec_mem_mem_WE),
					   .D_OUT_1(m_readyVec_mem_mem_D_OUT_1),
					   .D_OUT_2(),
					   .D_OUT_3(),
					   .D_OUT_4(),
					   .D_OUT_5());

  // submodule m_reqVec_mem_mem
  RegFile #(.addr_width(32'd6),
	    .data_width(32'd1),
	    .lo(6'h0),
	    .hi(6'd63)) m_reqVec_mem_mem(.CLK(CLK),
					 .ADDR_1(m_reqVec_mem_mem_ADDR_1),
					 .ADDR_2(m_reqVec_mem_mem_ADDR_2),
					 .ADDR_3(m_reqVec_mem_mem_ADDR_3),
					 .ADDR_4(m_reqVec_mem_mem_ADDR_4),
					 .ADDR_5(m_reqVec_mem_mem_ADDR_5),
					 .ADDR_IN(m_reqVec_mem_mem_ADDR_IN),
					 .D_IN(m_reqVec_mem_mem_D_IN),
					 .WE(m_reqVec_mem_mem_WE),
					 .D_OUT_1(m_reqVec_mem_mem_D_OUT_1),
					 .D_OUT_2(m_reqVec_mem_mem_D_OUT_2),
					 .D_OUT_3(m_reqVec_mem_mem_D_OUT_3),
					 .D_OUT_4(),
					 .D_OUT_5());

  // submodule m_values_mem_mem
  RegFile #(.addr_width(32'd6),
	    .data_width(32'd512),
	    .lo(6'h0),
	    .hi(6'd63)) m_values_mem_mem(.CLK(CLK),
					 .ADDR_1(m_values_mem_mem_ADDR_1),
					 .ADDR_2(m_values_mem_mem_ADDR_2),
					 .ADDR_3(m_values_mem_mem_ADDR_3),
					 .ADDR_4(m_values_mem_mem_ADDR_4),
					 .ADDR_5(m_values_mem_mem_ADDR_5),
					 .ADDR_IN(m_values_mem_mem_ADDR_IN),
					 .D_IN(m_values_mem_mem_D_IN),
					 .WE(m_values_mem_mem_WE),
					 .D_OUT_1(m_values_mem_mem_D_OUT_1),
					 .D_OUT_2(),
					 .D_OUT_3(),
					 .D_OUT_4(),
					 .D_OUT_5());

  // rule RL_m_doInit
  assign CAN_FIRE_RL_m_doInit = !m_didInit ;
  assign WILL_FIRE_RL_m_doInit = CAN_FIRE_RL_m_doInit ;

  // rule RL_m_checkOldest
  assign CAN_FIRE_RL_m_checkOldest = m_didInit ;
  assign WILL_FIRE_RL_m_checkOldest = m_didInit ;

  // rule RL_m_doAllocSlot
  assign CAN_FIRE_RL_m_doAllocSlot = m_didInit && EN_enq ;
  assign WILL_FIRE_RL_m_doAllocSlot = CAN_FIRE_RL_m_doAllocSlot ;

  // rule RL_m_valueReady
  assign CAN_FIRE_RL_m_valueReady = m_didInit && EN_setValue ;
  assign WILL_FIRE_RL_m_valueReady = CAN_FIRE_RL_m_valueReady ;

  // rule RL_m_nEntries_updateCounter
  assign CAN_FIRE_RL_m_nEntries_updateCounter = 1'd1 ;
  assign WILL_FIRE_RL_m_nEntries_updateCounter = 1'd1 ;

  // inlined wires
  assign m_oldestIsReady_wget =
	     m_nEntries_ctr != 7'd0 &&
	     m_reqVec_mem_mem_D_OUT_1 == m_readyVec_mem_mem_D_OUT_1 ;

  // register m_didInit
  assign m_didInit_D_IN = 1'd1 ;
  assign m_didInit_EN = WILL_FIRE_RL_m_doInit && m_initIdx == 6'd63 ;

  // register m_initIdx
  assign m_initIdx_D_IN = m_initIdx + 6'd1 ;
  assign m_initIdx_EN = CAN_FIRE_RL_m_doInit ;

  // register m_nEntries_ctr
  assign m_nEntries_ctr_D_IN = new_value__h405 ;
  assign m_nEntries_ctr_EN = 1'd1 ;

  // register m_nEntries_zero
  assign m_nEntries_zero_D_IN = new_value__h405 == 7'd0 ;
  assign m_nEntries_zero_EN = 1'd1 ;

  // register m_nextDeq
  assign m_nextDeq_D_IN = m_nextDeq + 6'd1 ;
  assign m_nextDeq_EN = EN_deq ;

  // register m_nextEnq
  assign m_nextEnq_D_IN = m_nextEnq + 6'd1 ;
  assign m_nextEnq_EN = EN_enq ;

  // submodule m_readyVec_mem_mem
  assign m_readyVec_mem_mem_ADDR_1 = m_nextDeq ;
  assign m_readyVec_mem_mem_ADDR_2 = 6'h0 ;
  assign m_readyVec_mem_mem_ADDR_3 = 6'h0 ;
  assign m_readyVec_mem_mem_ADDR_4 = 6'h0 ;
  assign m_readyVec_mem_mem_ADDR_5 = 6'h0 ;
  assign m_readyVec_mem_mem_ADDR_IN =
	     WILL_FIRE_RL_m_valueReady ? setValue_id : m_initIdx ;
  assign m_readyVec_mem_mem_D_IN =
	     WILL_FIRE_RL_m_valueReady && m_reqVec_mem_mem_D_OUT_2 ;
  assign m_readyVec_mem_mem_WE =
	     WILL_FIRE_RL_m_valueReady || WILL_FIRE_RL_m_doInit ;

  // submodule m_reqVec_mem_mem
  assign m_reqVec_mem_mem_ADDR_1 = m_nextDeq ;
  assign m_reqVec_mem_mem_ADDR_2 = setValue_id ;
  assign m_reqVec_mem_mem_ADDR_3 = m_nextEnq ;
  assign m_reqVec_mem_mem_ADDR_4 = 6'h0 ;
  assign m_reqVec_mem_mem_ADDR_5 = 6'h0 ;
  assign m_reqVec_mem_mem_ADDR_IN =
	     WILL_FIRE_RL_m_doAllocSlot ? m_nextEnq : m_initIdx ;
  assign m_reqVec_mem_mem_D_IN =
	     WILL_FIRE_RL_m_doAllocSlot && !m_reqVec_mem_mem_D_OUT_3 ;
  assign m_reqVec_mem_mem_WE =
	     WILL_FIRE_RL_m_doAllocSlot || WILL_FIRE_RL_m_doInit ;

  // submodule m_values_mem_mem
  assign m_values_mem_mem_ADDR_1 = m_nextDeq ;
  assign m_values_mem_mem_ADDR_2 = 6'h0 ;
  assign m_values_mem_mem_ADDR_3 = 6'h0 ;
  assign m_values_mem_mem_ADDR_4 = 6'h0 ;
  assign m_values_mem_mem_ADDR_5 = 6'h0 ;
  assign m_values_mem_mem_ADDR_IN = setValue_id ;
  assign m_values_mem_mem_D_IN = setValue_data ;
  assign m_values_mem_mem_WE = EN_setValue ;

  // remaining internal signals
  assign new_value__h405 = x__h422 - y__h391 ;
  assign x__h422 = m_nEntries_ctr + y__h393 ;
  assign y__h391 = EN_deq ? 7'd1 : 7'd0 ;
  assign y__h393 = EN_enq ? 7'd1 : 7'd0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        m_didInit <= `BSV_ASSIGNMENT_DELAY 1'd0;
	m_initIdx <= `BSV_ASSIGNMENT_DELAY 6'd0;
	m_nEntries_ctr <= `BSV_ASSIGNMENT_DELAY 7'd0;
	m_nEntries_zero <= `BSV_ASSIGNMENT_DELAY 1'd1;
	m_nextDeq <= `BSV_ASSIGNMENT_DELAY 6'd0;
	m_nextEnq <= `BSV_ASSIGNMENT_DELAY 6'd0;
      end
    else
      begin
        if (m_didInit_EN) m_didInit <= `BSV_ASSIGNMENT_DELAY m_didInit_D_IN;
	if (m_initIdx_EN) m_initIdx <= `BSV_ASSIGNMENT_DELAY m_initIdx_D_IN;
	if (m_nEntries_ctr_EN)
	  m_nEntries_ctr <= `BSV_ASSIGNMENT_DELAY m_nEntries_ctr_D_IN;
	if (m_nEntries_zero_EN)
	  m_nEntries_zero <= `BSV_ASSIGNMENT_DELAY m_nEntries_zero_D_IN;
	if (m_nextDeq_EN) m_nextDeq <= `BSV_ASSIGNMENT_DELAY m_nextDeq_D_IN;
	if (m_nextEnq_EN) m_nextEnq <= `BSV_ASSIGNMENT_DELAY m_nextEnq_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    m_didInit = 1'h0;
    m_initIdx = 6'h2A;
    m_nEntries_ctr = 7'h2A;
    m_nEntries_zero = 1'h0;
    m_nextDeq = 6'h2A;
    m_nextEnq = 6'h2A;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkScoreboardQA

